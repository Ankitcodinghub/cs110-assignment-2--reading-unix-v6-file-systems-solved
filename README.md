# cs110-assignment-2--reading-unix-v6-file-systems-solved
**TO GET THIS SOLUTION VISIT:** [CS110 Assignment 2- Reading Unix v6 File Systems Solved](https://www.ankitcodinghub.com/product/cs110-assignment-2-reading-unix-v6-file-systems-solved/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;113678&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;1&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (1 vote)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;CS110 Assignment 2- Reading Unix v6 File Systems Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (1 vote)    </div>
    </div>
An archaeological expedition in Murray Hill, NJ has uncovered some magnetic disk drives from the mid-1970s. After considerable effort, the dig‚Äôs technical expert read the contents of the drives, and for each disk drive, she created a local file to be an exact bitwise copy of the disk‚Äôs data.

The archaeologists determined the data on the disks was stored using the Version 6 Unix file system. Sadly, none of the archaeologists made it through CS110, so they haven‚Äôt been able to read the image contents. Your task is to write a program that understands the Unix v6 file system to extract the file system data.

Getting started

All coding should be done on the myth cluster machines, as that‚Äôs where we‚Äôll be testing your submission. To get your own copy of the starter code, you should clone the master mercurial repository we‚Äôve set up for you by typing:

myth22&gt; hg clone /usr/class/cs110/repos/assign2/$USER assign2

Doing so will create an assign2 directory within your own space, and you can descend into that directory to land on the collection of files you‚Äôll be modifying to arrive at a working product.

Building, running, testing, and committing local changes

To build the project, cd into your local repository and type

myth22&gt; make

To test your work, cd into your local repository and type

myth22&gt; ./diskimageaccess &lt;options&gt; &lt;diskimagePath&gt;

You can visually compare your output to that generated by my own solution by typing

myth22&gt; ./slink/diskimageaccess_soln &lt;options&gt; &lt;diskimagePath&gt;

diskimagePath&gt; should be the path to one of the test disks located in /usr/ class/cs110/samples/assign2/testdisks. We currently have three test disks: basicDiskImage, depthFileDiskImage, and dirFnameSizeDiskImage.

diskimageaccess recognizes two flags as valid &lt;options&gt;:

‚óè -i: test the inode and file layers

‚óè -p: test the filename and pathname layers

For example, to run both the inode and filename tests on the basic disk, you could run

myth22&gt; ln -s /usr/class/cs110/samples/assign2/testdisks testdisks myth22&gt; ./diskimageaccess -ip testdisks/basicDiskImage

The expected output for running diskimageaccess on each disk image X is stored in the X.gold file inside the testdisks directory. In fact, we‚Äôre leveraging even another CS107 tool: the sanitycheck tool, which you can read about right here.

In particular, if you type

myth22&gt; /usr/class/cs110/tools/sanitycheck

at the command prompt while in your assign2 directory, the sanitycheck script will exercise your implementation in precisely the same way our own grading scripts will. We won‚Äôt always expose all of the functionality tests like we are for Assignment 2, but we are this time.

As you develop, it‚Äôs a good idea to locally commit your work to your own repository by typing

myth22&gt; hg commit

as doing so minimizes the chances that you‚Äôll lose your work.

Submitting

When time comes for you to push your submission back to the master (which is the version we‚Äôll grade), do one final hg commit if needed, and then type

myth22&gt; /usr/class/cs110/tools/submit

What we provide

The files we provide you fall into three categories.

The Version 6 Unix header files (filsys.h, ino.h, direntv6.h) These are described below.

The test harness (diskimageaccess.c, chksumfile.[ch], unixfilesystems.[ch])

These files provide the infrastructure for building your code and running our tests against it.

File system module (diskimg.[ch], inode.[ch], file.[ch], pathname.[ch])

The test code we give you interfaces with the file system using a layered API that we‚Äôve already designed. For each of the layers that you‚Äôll need to implement for this assignment, there is a header file that defines the interface to the layer and a corresponding .c file that should contain the implementation.

The layers are:

Block layer (diskimg.[ch])

This defines and implements the interface for reading and writing sectors (note that the words block and sector are used interchangeably) on the disk image. We give you an implementation of this layer that should be sufficient for this assignment.

inode layer (inode.[ch])

This defines and implements the interface for reading the file system‚Äôs inodes. This includes the ability to look up inodes by inumber and to get the block/sector number of the nth block of the inode‚Äôs data.

File layer (file.[ch])

This defines and implements the interface for reading blocks of data from a file by specifying its inumber. This is one of the two layers our tests explicitly exercise.

Filename layer (directory.[ch])

This defines and implements the interface for implementing Unix directories on top of files. Its primary function is to get information about a single directory entry.

Pathname layer (pathname.[ch])

This defines and implements the interface to look up a file by its absolute pathname. This is the second of the two layers we explicitly test.

You are welcome to modify any of the files we give you. When making changes in the test harness, do so in a backward compatible way so that the testing scripts we give you continue to work. In other words, it‚Äôs fine to add testing and debugging code, but make sure that when we run your program with -i and -p, its output has the same format with or without your changes, so our automated tests won‚Äôt break.

Suggested Implementation Order

The starter code contains a number of unfinished functions. We suggest you attack them in the following order:

‚óè inode_iget and inode_indexlookup in inode.c.

‚óè file_getblock in file.c. After this step, your code should pass the inode level functionality tests.

‚óè directory_findname in directory.c.

‚óè pathname_lookup in pathname.c. Refer to Section 2.5.6 of the Salzer and Kaashoek book for this part. Afterward, all the pathname tests should pass.

Grading

We will grade your assignment based on a combination of test results and code quality.

‚óè Code test results: 60 points

‚óè Clean build and clean valgrind reports: 6 points

‚óè Code quality: graded on bucket system [exceptional, solid, minor-problems, major-problems, etc.]

First, we‚Äôll run your code on a set of test disk images and check that your program gives the expected output. You have access to all of the images we‚Äôll use for grading and the correct output for each of them.

If this were a real archaeological dig, you would have been given only the disk image and a computer. But to make things easier, we‚Äôve provided you with starter code that tries to read all the files on the image and outputs checksums of the inode and file contents. We‚Äôve also computed these checksums using a working implementation of the assignment. If your checksums match ours, then your code is correctly reading the data off the disk.

Finally, we‚Äôll read through your code and give you comments on style and overall quality. We‚Äôll look for places where you inappropriately break the layering of the file system or make other mistakes that don‚Äôt necessarily cause your program to generate the wrong output. We‚Äôll also look for common C programming errors such as memory leaks and use of the heap where stack allocation is more appropriate. Finally, we‚Äôll check that your code is easy to read: It should be wellformatted, organized, and be easy to follow.

Unix v6 file system supplement

Section 2.5 of the Salzer and Kaashoek book contains most of what you need to know about the Unix v6 file system in order to do this assignment. The information below is supplementary to the textbook, so it assumes you‚Äôve already read and understand the material there.

Header files and structures

In the starter code we‚Äôve provided C structs corresponding to the file system‚Äôs on-disk data structures. These structs have the same layout in memory as the structures have on disk. They include:

structfilsys (filsys.h)

Corresponds to the superblock of the file system. This is a slightly modified copy of the header file from Version 6 Unix. structinode (ino.h)

Corresponds to a single inode. Again this comes from Version 6 of Unix, with some small modifications.

structdirentv6 (direntv6.h)

Corresponds to a directory entry. This was copied from section 2.5 in the textbook.

In addition, unixfilesystem.h contains a description of the file system layout, including the sector address of the superblock and of the start of the inode region.

Legacy of an old machine

Back in the 1970s, storage space ‚Äî both on disk and in main memory ‚Äî was at a premium. As a result, the Unix v6 file system goes to lengths to reduce the size of data it stores. You‚Äôll notice that many integer values in the structs we provided are stored using only 16 bits, rather than today‚Äôs more standard 32 or 64. (In our code we use the type int16_t from stdint.h to get a 16-bit integer, but back in the ‚Äô70s, the C int type was 16 bits wide.)

In another space-saving move, the designers of the file system stored the inode‚Äôs size field as a

24-bit integer. There‚Äôs no 24-bit integer type in C, so we represent this value using two fields in

the inodestruct: i_size1, which contains the least-significant 16 bits of the value, and i_size0, which contains the most-significant 8 bits of the value. We provide a function inode_getsize in inode.c that assembles these two fields into a normal C integer for you.

The first inode

Since there is no inode with an inumber of 0, the designers of the file system decided not to waste the 32 bytes of disk space to store it. The first inode in the first inode block has inumber 1; this inode corresponds to the root directory for the file system. (See unixfilesystem.h for details.) Be careful not to assume that the first inode has an inumber of 0! Off-by-one errors are the worst.

inode‚Äôs i_mode

The 16-bit integer i_mode in the inodestruct isn‚Äôt really a number; rather, the individual bits of the field indicate various properties of the inode. ino.h contains #defines which describe what each bit means.

For instance, we say an inode is allocated if it points to an existing file. The most-significant bit (i.e. bit 15) of i_mode indicates whether the inode is allocated or not. So the C expression (i_mode &amp; IALLOC) == 0 is true if the inode is unallocated and false otherwise.

Similarly, bit 12 of i_mode indicates whether the file uses the large file mapping scheme. So if (i_mode &amp; ILARG) != 0 , then the inode‚Äôs i_addr fields point at indirect and doubly-indirect blocks rather than directly at the data blocks.

Bits 14 and 13 form a 2-bit wide field specifying the type of file. This field is 0 for regular files and 2 (i.e. binary 10, or the constant IFDIR) for directories. So the expression (i_mode &amp; IFMT) == IFDIR is true if the inode is a directory, and false otherwise.
